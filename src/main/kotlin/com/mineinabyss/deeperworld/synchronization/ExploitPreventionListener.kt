package com.mineinabyss.deeperworld.synchronization

import com.mineinabyss.deeperworld.world.section.correspondingLocation
import com.mineinabyss.deeperworld.world.section.inSectionOverlap
import io.papermc.paper.event.block.BlockBreakBlockEvent
import org.bukkit.block.Block
import org.bukkit.event.EventHandler
import org.bukkit.event.Listener
import org.bukkit.event.block.BlockPistonExtendEvent
import org.bukkit.event.block.BlockPistonRetractEvent
import org.bukkit.inventory.ItemStack

object ExploitPreventionListener : Listener {

    @EventHandler
    fun BlockPistonExtendEvent.onPistonExtendEvent() {
        val corrBlock = block.location.correspondingLocation?.block ?: return
        val corrBlocks = mutableListOf<Block>()

        if (blocks.all { b -> !b.location.inSectionOverlap }) return
        if (!corrBlock.location.isChunkLoaded) corrBlock.chunk.load()

        blocks.forEach { corrBlocks.add(it.location.correspondingLocation?.block ?: return@forEach) }
        BlockPistonRetractEvent(corrBlock, corrBlocks, direction).callEvent()
    }

    @EventHandler
    fun BlockPistonRetractEvent.onPistonRetractEvent() {
        val corrBlock = block.location.correspondingLocation?.block ?: return
        val corrBlocks = mutableListOf<Block>()

        if (blocks.all { b -> !b.location.inSectionOverlap }) return
        if (!corrBlock.location.isChunkLoaded) corrBlock.chunk.load()

        blocks.forEach { corrBlocks.add(it.location.correspondingLocation?.block ?: return@forEach) }
        BlockPistonRetractEvent(corrBlock, corrBlocks, direction).callEvent()
    }

    @EventHandler
    fun BlockBreakBlockEvent.onPistonBreakBlock() {
        val corrBlock = block.location.correspondingLocation?.block ?: return
        val corrSource = source.location.correspondingLocation?.block ?: return
        BlockBreakBlockEvent(corrBlock, corrSource, emptyList<ItemStack>()) // Empty drops to avoid dupes
    }
}
